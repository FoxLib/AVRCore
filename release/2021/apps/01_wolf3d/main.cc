#include <avr/interrupt.h>
#include <graphics.cc>
#include <keyboard.cc>
#include <math.h>

graphics G;
keyboard K;

static const byte map[16][16] = {

    {1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1},
    {1, 0, 1, 0, 0, 0, 2, 0, 1, 0, 0, 0, 0, 0, 0, 1},
    {1, 0, 1, 0, 1, 0, 0, 0, 1, 0, 1, 1, 0, 1, 0, 1},
    {1, 0, 0, 0, 1, 1, 1, 0, 1, 0, 1, 0, 0, 1, 0, 1},
    {1, 0, 1, 1, 1, 0, 1, 0, 0, 0, 1, 0, 1, 0, 0, 1},
    {1, 2, 1, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 1, 0, 1},
    {1, 0, 1, 0, 1, 2, 2, 0, 0, 0, 1, 1, 1, 0, 0, 1},
    {1, 0, 1, 0, 1, 0, 1, 1, 0, 1, 1, 0, 0, 0, 1, 1},
    {1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 1},
    {1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 0, 0, 1},
    {1, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 1},
    {1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 1, 0, 1, 0, 1},
    {1, 0, 1, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1},
    {1, 0, 2, 2, 2, 0, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1},
    {2, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1},
    {2, 2, 2, 2, 2, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1}
};

static const byte tex[2][16][16] = {

    {
        {0x77, 0x77, 0x77, 0x77, 0x77, 0x77, 0x77, 0x00, 0x77, 0x77, 0x77, 0x77, 0x77, 0x77, 0x77, 0x00},
        {0x77, 0x88, 0x88, 0x88, 0x88, 0x88, 0x88, 0x00, 0x77, 0x88, 0x88, 0x88, 0x88, 0x88, 0x88, 0x00},
        {0x77, 0x88, 0x88, 0x88, 0x88, 0x88, 0x88, 0x00, 0x77, 0x88, 0x88, 0x88, 0x88, 0x88, 0x88, 0x00},
        {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
        {0x77, 0x77, 0x77, 0x00, 0x77, 0x77, 0x77, 0x77, 0x77, 0x77, 0x77, 0x00, 0x77, 0x77, 0x77, 0x77},
        {0x88, 0x88, 0x88, 0x00, 0x77, 0x88, 0x88, 0x88, 0x88, 0x88, 0x88, 0x00, 0x77, 0x88, 0x88, 0x88},
        {0x88, 0x88, 0x88, 0x00, 0x77, 0x88, 0x88, 0x88, 0x88, 0x88, 0x88, 0x00, 0x77, 0x88, 0x88, 0x88},
        {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
        {0x77, 0x77, 0x77, 0x77, 0x77, 0x77, 0x77, 0x00, 0x77, 0x77, 0x77, 0x77, 0x77, 0x77, 0x77, 0x00},
        {0x77, 0x88, 0x88, 0x88, 0x88, 0x88, 0x88, 0x00, 0x77, 0x88, 0x88, 0x88, 0x88, 0x88, 0x88, 0x00},
        {0x77, 0x88, 0x88, 0x88, 0x88, 0x88, 0x88, 0x00, 0x77, 0x88, 0x88, 0x88, 0x88, 0x88, 0x88, 0x00},
        {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
        {0x77, 0x77, 0x77, 0x00, 0x77, 0x77, 0x77, 0x77, 0x77, 0x77, 0x77, 0x00, 0x77, 0x77, 0x77, 0x77},
        {0x88, 0x88, 0x88, 0x00, 0x77, 0x88, 0x88, 0x88, 0x88, 0x88, 0x88, 0x00, 0x77, 0x88, 0x88, 0x88},
        {0x88, 0x88, 0x88, 0x00, 0x77, 0x88, 0x88, 0x88, 0x88, 0x88, 0x88, 0x00, 0x77, 0x88, 0x88, 0x88},
        {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
    },
    {   // Красные кирпичи
        {0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x00},
        {0xff, 0x44, 0x44, 0x44, 0x44, 0x44, 0x44, 0x00, 0xff, 0x44, 0x44, 0x44, 0x44, 0x44, 0x44, 0x00},
        {0xff, 0x44, 0x44, 0x44, 0x44, 0x44, 0x44, 0x00, 0xff, 0x44, 0x44, 0x44, 0x44, 0x44, 0x44, 0x00},
        {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
        {0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0xff},
        {0x44, 0x44, 0x44, 0x00, 0xff, 0x44, 0x44, 0x44, 0x44, 0x44, 0x44, 0x00, 0xff, 0x44, 0x44, 0x44},
        {0x44, 0x44, 0x44, 0x00, 0xff, 0x44, 0x44, 0x44, 0x44, 0x44, 0x44, 0x00, 0xff, 0x44, 0x44, 0x44},
        {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
        {0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x00},
        {0xff, 0x44, 0x44, 0x44, 0x44, 0x44, 0x44, 0x00, 0xff, 0x44, 0x44, 0x44, 0x44, 0x44, 0x44, 0x00},
        {0xff, 0x44, 0x44, 0x44, 0x44, 0x44, 0x44, 0x00, 0xff, 0x44, 0x44, 0x44, 0x44, 0x44, 0x44, 0x00},
        {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
        {0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0xff},
        {0x44, 0x44, 0x44, 0x00, 0xff, 0x44, 0x44, 0x44, 0x44, 0x44, 0x44, 0x00, 0xff, 0x44, 0x44, 0x44},
        {0x44, 0x44, 0x44, 0x00, 0xff, 0x44, 0x44, 0x44, 0x44, 0x44, 0x44, 0x00, 0xff, 0x44, 0x44, 0x44},
        {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
    }
};

const float sqrt2 = 0.7071; // 1/sqrt(2)

int main() {

    float px = 1.5, py = 1.2, a = 0.0;

    byte bounce;
    int  tex_id;

    byte cl11 = G.rgb( 32,  32, 255);
    byte cl22 = G.rgb( 32, 128,  32);
    byte cl88 = G.rgb(128, 128, 128);

    heap(vm, 0xf000);

    int buffer_id = 0;

    G.screen(0);

    for (;;) {

        int current_bank = buffer_id ? 0x20 : 0x30;

        // Предвычисление
        float a_cos = sqrt2 * cos(a),
              a_sin = sqrt2 * sin(a);

        // Стартовая позиция точки
        int xi_ = (int) px; float x_ = px - xi_; float x; int xi;
        int yi_ = (int) py; float y_ = py - yi_; float y; int yi;

        // Просмотр горизонта событий
        for (int i = -160; i < 160; i += 2) {

            // Скопировать инициирующие точки
            x = x_; xi = xi_;
            y = y_; yi = yi_;

            // Вычисление смещения
            float fi = (float)i / 160.0;

            // Поворот точки
            float dx = a_cos*fi + a_sin;
            float dy = a_cos    - a_sin*fi;

            // Предвычисление
            float xa = (dx > 0) ? 1.0 :  0.0;
            float ya = (dy > 0) ? 1.0 :  0.0;
            float xb = (dx > 0) ? 1.0 : -1.0;
            float yb = (dy > 0) ? 1.0 : -1.0;
            float xc = 1.0 - xa;
            float yc = 1.0 - ya;
            float t  = 0.0, t1, t2;

            // Итерации по блокам
            for (int j = 0; j < 32; j++) {

                // Расчет разностей
                t1 = dx ? (xa - x) / dx : 100.0;
                t2 = dy ? (ya - y) / dy : 100.0;

                // Правая или левая стенка
                if (t1 < t2) {

                    x   = xc;
                    xi += xb;
                    y  += t1*dy;
                    t  += t1;
                    bounce = 0;

                    if      (y >= 1.0) y -= 1.0;
                    else if (y  < 0.0) y += 1.0;
                }
                // Верхняя или нижняя стена
                else {

                    y   = yc;
                    yi += yb;
                    x  += t2*dx;
                    t  += t2;
                    bounce = 1;

                    if      (x >= 1.0) x -= 1.0;
                    else if (x <  0.0) x += 1.0;
                }

                // Тест точки пересечения
                if (map[yi][xi]) {

                    unsigned int cc;

                    bank(current_bank);
                    word z = i + 160;

                    // Вычисление Y = PPD / Z
                    t = 100.0 / t;
                    tex_id = map[yi][xi] - 1;

                    // Границы
                    int y1 = 100 - t,
                        y2 = 100 + t;

                    // Смотря от чего отбился луч, оттуда взята текстура
                    int tx = (bounce ? x : y) * 32,
                        tym = 0,
                        ty  = 0,
                        dty = y2 - y1;

                    // Если начало стены находится за верхом
                    if (y1 < 0) {

                        tym  = 32 * (-y1);
                        ty  += (tym / dty);
                        tym %= dty;
                    }

                    // Рисовать сверху вниз
                    for (int k = 0; k < 200; k++) {

                        // Расчет верха, стены и пола
                        if (k < y1) cc = cl11;
                        // Рисование стены
                        else if (k < y2) {

                            // Целочисленное вычисление положения текстуры
                            tym += 32; while (tym > dty) { tym -= dty; ty++; }

                            // Вычисление картинки
                            if ((((i>>1) ^ k) & 1) && t < 50) {
                                cc = t > 30 ? cl88 : 0x00;
                            } else {
                                cc = tex[tex_id][ty&15][tx&15];
                            }
                        }
                        // Рисовать пол
                        else cc = cl22;

                        // Более скоростное рисование
                        vm[z]   = cc;
                        vm[z+1] = cc;

                        z += 320; if (z >= 4096) { bank(inp(0) + 1); z -= 4096; }
                    }

                    break;
                }
            }
        }

        // Обмен банков местами
        buffer_id = 1 - buffer_id;
        G.screen(buffer_id);

        switch (K.getch()) {

            case key_UP: { px += 0.25 * a_sin; py += 0.25 * a_cos; break; }
            case key_DN: { px -= 0.25 * a_sin; py -= 0.25 * a_cos; break; }
            case key_LF: { a -= 0.25; break; }
            case key_RT: { a += 0.25; break; }
        }
    }
}
